# ! /usr/bin/python
# -*- coding: utf-8 -*-

# Description: Functions used in determination of sphericity and roundness

# import modulues
import numpy as np

# import module for image manipulation
import cv2

# import plotting module
import matplotlib.pyplot as plt

# from scipy.ndimage.filters import gaussian_filter1d
# import scipy optimization tool for least squares fitting
from scipy.optimize import leastsq

# custom lowess fitting function by Ariel Rokem
# github.com/arokem/lowess
import lowess_arokem as lowess_ar


# ref: stackoverflow.com/questions/4337902/
# how-to-fill-opencv-image-with-one-solid-color
# stackoverflow member: Kimmo
def create_blank(width, height, rgb_color=(0, 0, 0)):
    """Create new image(numpy array) filled with certain color in RGB."""
    # Create black blank image
    image = np.zeros((height, width, 3), np.uint8)

    # Since OpenCV uses BGR, convert the color first
    color = tuple(reversed(rgb_color))
    # Fill image with color
    image[:] = color

    return image

# the distance formula
def calc_dist(xc, yc, x, y):
    """
    Calculate the distance of each 2D points from the center c=(xc, yc)
    or a  given point (xc, yc).
    """
    return np.sqrt((x-xc)**2 + (y-yc)**2)


# used to fill holes in binary images of sand particles
# ref: //www.learnopencv.com/
# filling-holes-in-an-image-using-opencv-python-c/
# author: SATYA MALLICK
def fillholes(img):
    """
    Fill holes in the particles after binarization, thresholded images
    could have some holes inside the particles.

    Input: img, thresholded image, binary image

    Ouput: Image with any holes in the sand particle filled. White particle
           with black background.
    """
    # make a copy the thresholded image
    img_floodfill = img.copy()

    # fill holes present in the sand particle
    # mask used for flood filling
    # the size needs to be 2 pixels larger than the image
    h, w = img.shape
    mask = np.zeros((h+2, w+2), np.uint8)

    # floodfill from point(10, 50) to avoid the annotation
    cv2.floodFill(img_floodfill, mask, (10, 50), 255)

    # invert the floodfilled image
    img_floodfill_inv = cv2.bitwise_not(img_floodfill)

    # combine the two images to get the foreground with holes filled
    img_out = img | img_floodfill_inv

    return img_out


def cart2polar(cnt, center):
    """
    Convert cartesian coordinates to polar coordinates with respect to the
    specified center.
    Input: cnt, [[[x1, y1], [x2, y2], ...]]] contour points
           center, center with respect to which the polar coordinates
           were computed

    Output: phi, angles of the polar coordinates
            rho, radius of the polar coordinates with respect to the center
    """
    # get the abscissas and ordinates of the contour
    xcon = cnt[:, 0][:, 0]
    ycon = cnt[:, 0][:, 1]

    # translate to the center
    xs = xcon - center[0]
    ys = ycon - center[1]

    # radius of the translated points from the center
    rho = np.sqrt(xs**2 + ys**2)

    # angle of the translated points
    phi = np.arctan2(ys, xs)

    # numpy atan2 returns from -pi to pi
    # if phi < 0:
    #     phi = phi + 2 * np.pi
    # else:
    #     phi
    phi[phi < 0] = phi[phi < 0] + 2 * np.pi

    return phi, rho


def polar2cart(phi, rho, center):
    """
    Convert from polar coordinates to cartesian coordinates. The coordinates
    of the center of rotation is from the origin of the cartesian systems.

    Input: phi, numpy array of angles of the polar coordinates, in radians
           rho, numpy array of the radii with respect to center of rotation
           center, center of rotation in the cartesian coordinate system

    Ouput: xs, numpy array of abscissas
           ys, numpy array of ordinates
    """
    # center of rotation
    cX, cY = center

    # conversion from polar to cartesian
    xs = np.cos(phi) * rho + cX
    ys = np.sin(phi) * rho + cY

    return xs, ys


def smooth_contour(cnt, center, span, filename):
    """
    Smooth the outline countour generated by openCV using cubic spline
    interpolation. The contour points in cartesian coordinate systems is
    converted to polar coordinate system with center of mass as the center of
    rotation. Smoothing is performed in the polar coordinate system and these
    smoothed polar coordinates are returned. Also save an image of the original
    2D image and the smoothed contour for later reference.

    Input: cnt, inter array of array of points
           [[[x1, y1], [x2, y2],... [xi,yi]]], center,
           center of rotation for convertion from cartesian to
           polar coordinates
           curve when converting from cartesian to polar and then smoothing
           filename, filename of the 2D image of the particle for saving the
           image with smoothed contour

    Output: phi_sm, the angle in polar coordinate system of the smoothed line
            rho_sm, the radius in polar coordinate system of the smoothed line
            xsm, the smoothed x-coordinates
            ysm, the smoothed y-coordinates
    """
    # create an empty image, openCV is (B, G, R)
    # colors from colorbrewer,
    # //colorbrewer2.org/#type=diverging&scheme=RdYlBu&n=5
    dark_orange = (253, 174, 97)
    light_yellow = (255, 255, 191)

    # change from cartesian coordinate system to polar coordinate system
    # with respect to the centroid, the radii are the two distances to the
    # the edge of the particle from the centroid
    phi, rho = cart2polar(cnt, center)

    # smooth the contour with LOESS, the code for LOESS is from Ariel Rokem,
    # Using it as a blackbox, Later R loess?
    phi_sm = phi
    rho_sm = lowess_ar.lowess(phi, rho, phi_sm, deg=2, l=0.07)

    # rho_sm = gaussian_filter1d(rho_sm, int(0.02 * npts))

    # smoothed contour in cartesian coordinates for plotting
    xsm, ysm = polar2cart(phi_sm, rho_sm, center)

    # close the contour
    xsm[-1] = xsm[0]
    ysm[-1] = ysm[0]

    cnt_sm = np.array([[int(x), int(y)] for x, y in zip(xsm, ysm)])

    # create a blank image with white background, draw the image of
    # of the smoothed particle and draw the original particle shape too
    img = create_blank(640, 480, rgb_color=(0, 0, 0))
    img = cv2.drawContours(img, [cnt_sm], 0, light_yellow, -1)
    img = cv2.drawContours(img, [cnt], 0, dark_orange, 2)
    cv2.imwrite('../plots/' + filename + 'sm_cnt.png', img)

    # return the array of smoothed contour
    return phi_sm, rho_sm, xsm, ysm


def particle_countour_params(cnt):
    """
    Derive various partice shape parameters from the boundary trace of the
    particle. Units: pixels

    Input: cnt, the outer most contour (boundary trace) of the particle.

    Output: Center of mass, (cX, cY)
            Area, area
            Perimeter, perimeter
            Minimum enclosing circle center and radius, minEnclosingCircle,
            ((mecX, mecY), mecrad)
            Aspect ratio, aspect_ratio
            Diameter: diameter
            Major and min axis of the fitted ellipse: MajMinAxis, (MA, ma)
            Minimum area bounding rectangle, minAeaRect,
                (center (x,y), (width, height), angle of rotation)
            Solidity, solidity
    """
    # ref: //docs.opencv.org/trunk/dd/d49/
    # tutorial_py_contour_features.html

    # find the center of mass from the moments of the contour
    M = cv2.moments(cnt)
    cX = int(M["m10"] / M["m00"])
    cY = int(M["m01"] / M["m00"])

    # aspect ratio
    x, y, w, h = cv2.boundingRect(cnt)
    aspect_ratio = float(w)/h
    # print('boundingRect: ', cv2.boundingRect(cnt))
    # solidity
    area = cv2.contourArea(cnt)
    hull = cv2.convexHull(cnt)
    hull_area = cv2.contourArea(hull)
    solidity = float(area)/hull_area

    # Equivalent Diameter is the diameter of the circle whose area
    # is same as the contour area
    equi_diameter = np.sqrt(4.0 * area/np.pi)

    # min enclosing circle
    perimeter = cv2.arcLength(cnt, True)
    (mecX, mecY), mecrad = cv2.minEnclosingCircle(cnt)

    # minimum area bounding rectangle
    rect = cv2.minAreaRect(cnt)
    # print('minAreaRect: ', rect)

    # fitting an ellipse
    el = cv2.fitEllipse(cnt)
    # print('Fitted ellipse: ', el)

    return {'centroid': (cX, cY), 'area': area, 'perimeter': perimeter,
            'minEnclosingCircle': ((mecX, mecY), mecrad),
            'aspect_ratio': aspect_ratio, 'diameter': equi_diameter,
            'ellipse': el, 'minAreaRect': rect, 'solidity': solidity}


def max_inscribed_circle(img, filename):
    """
    Determine the largest inscribed circle.

    Input: img, binary image

    Output: (idx_col, idx_row), inscribed_radius, the center of the maximum
            inscribed circle and its radius
    """

    # Calculates the distance to the closest zero pixel for each pixel,
    # the particle is white which is the non-zero (255), the background is
    # black black pixel have zero value. So distance transform is computing
    # the shorted distance of each pixel inside the particle to boundary of
    # the particle. DIST_L2 is Euclidean distance
    edt = cv2.distanceTransform(img, distanceType=cv2.DIST_L2,
                                maskSize=cv2.DIST_MASK_PRECISE)

    # the maximum pixel value, the farthest pixel value is the radius
    inscribed_radius = np.max(edt)

    # to determine the center, get the position of the max value, farthest
    # pixel, the way argmax works, it is necessary to unravel the index to
    # convert from 1D indexing to 2D indexing. The row and column indices
    # returned depends on the unravelling method. The default is (row, col),
    # therefore the center is (col, row)
    idx_max = np.argmax(edt)
    idx_row, idx_col = np.unravel_index(idx_max, img.shape)

    # save the figure
    fig, ax = plt.subplots()
    incircle = plt.Circle((idx_col, idx_row), inscribed_radius, fill=False)
    # cax = ax.imshow(edt, cmap=matplotlib.cm.gray)
    cax = ax.imshow(edt)
    fig.colorbar(cax)
    ax.plot(idx_col, idx_row, 'kx')
    ax.add_artist(incircle)
    plt.savefig("../plots/" + filename + "_maxinscir.png")
    plt.close()

    return {'maxInscribedCircle': ((idx_col, idx_row), inscribed_radius)}


def calc_sphericity(params):
    # 2d project area of the particle
    area_2d = params['area']

    # area of the minimum subscribing circle
    rad_mec = params['minEnclosingCircle'][1]
    area_mec = np.pi * rad_mec**2

    # area sphericity
    sa = area_2d/area_mec

    # diameter of the circle having the same area as the projected area
    dia_2d = np.sqrt(4.0/np.pi * area_2d)

    # diameter sphericity
    sd = dia_2d/(2.0 * rad_mec)

    # circle ratio sphericity
    sc = 2 * params['maxInscribedCircle'][1]/(2.0 * rad_mec)

    # perimeter sphericity
    sp = np.pi * dia_2d/params['perimeter']

    # width to length ratio sphericity
    swl = min(params['minAreaRect'][1])/max(params['minAreaRect'][1])

    return {'sa': sa, 'sd': sd, 'sc': sc, 'sp': sp, 'swl': swl}


# this algorithm is based on:
# //www.peterkovesi.com/matlabfns/LineSegments/maxlinedev.m
# by Peter Kovesi

def maxlinedev(x, y):
    """
    Find the point of maximum deviation in the contour from a line joining
    two points on the contour.

    Input: x, numpy array of abscissas of the contour
           y, numpy array of ordinates of the contour

    Output: maxdev, maximum deviation
            idxmaxdev, index of the point of maximum deviation
    """
    # error checking and handling, include later
    if len(x) == 1:
        print("WARNING: Contour contains only one point")

    # Distance between the end points
    x2mx1 = x[-1] - x[0]
    y2my1 = y[-1] - y[0]
    dist = np.sqrt((x2mx1)**2 + (y2my1)**2)

    if dist > np.finfo(float).eps:
        # distance from the line to each point on the contour
        dev = np.abs(x2mx1 * y[0] - y2my1 * x[0] - x2mx1 * y + y2my1 * x)/dist
    else:
        # end points are coincident, calcuate distance from the first point
        dev = calc_dist(x[0], y[0], x, y)

    # maximum deviation and index of maximum deviation
    maxdev = np.max(dev)
    idxmaxdev = np.argmax(dev)

    return maxdev, idxmaxdev


# This piece of code is based on
# //www.peterkovesi.com/matlabfns/LineSegments/????.m
# by Peter Kovesi

def lineseg(x, y, tol):
    """
    Form straight line segments from an boundary list.

    Input: x, numpy array of abscissas of the boundary
           y, numpy array of ordinates of the boundary
           tol, maximum deviation from the straight line before a segment
           is broken in two (measured in pixels)

    Output: array of numpy array containing
    """
    # indices of the first and last point of the contour
    fst = 0
    lst = len(x)

    # list to hold the list of segmented points
    seglist = [[x[0], y[0]]]

    while fst < lst:
        # find the size and position of the maximum deviation
        maxdev, idxmaxdev = maxlinedev(x[fst:lst], y[fst:lst])

        # while the maximum deviation from the line > tol shorten the line to
        # the point of maximum deviation by adjusting the last point
        while maxdev > tol:
            lst = fst + idxmaxdev + 1
            maxdev, idxmaxdev = maxlinedev(x[fst:lst], y[fst:lst])

        # add the last point for which deviation is less than tol to the
        # segemented list
        seglist.append([x[lst-1], y[lst-1]])
        # print('seglist: ', seglist)

        # rest the first and the last point for the next iteration
        fst = lst
        lst = len(x)

    return np.asarray(seglist)


# ref: https://stackoverflow.com/questions/20677795/
#      how-do-i-compute-the-intersection-point-of-two-lines-in-python
# credit goes to rook from Stackoverflow for line and intersection
def line(p1, p2):
    """
    Coefficients A, B, C of line equation (Ax + By = C) from
    the two endpoints p1, p2 of the line

    Input: p1, p2 the two points of the line segment

    Output: Coefficients of the line equation
    """
    A = (p1[1] - p2[1])
    B = (p2[0] - p1[0])
    C = (p1[0] * p2[1] - p2[0] * p1[1])
    return A, B, -C


def intersection(L1, L2):
    """
    Find the intersection point of the two lines
    A1 * x + B1 * y = C1
    A2 * x + B2 * y = C2
    The intersection point is:
    x = Dx/D
    y = Dy/D
    The determinant D
    A1 B1 which is      L1[0] L1[1]
    A2 B2               L2[0] L2[1]
    Dx:
    C1 B1 which is      L1[2] L1[1]
    C2 B2               L2[2] L2[1]
    and Dy:
    A1 C1 which is      L1[0] L1[2]
    A2 C2               L2[0] L2[2]

    Input: Line1, Line2 the two intersecting lines

    Output: x, y the point of intersection
    """

    D = L1[0] * L2[1] - L1[1] * L2[0]
    Dx = L1[2] * L2[1] - L1[1] * L2[2]
    Dy = L1[0] * L2[2] - L1[2] * L2[0]
    if D != 0:
        x = Dx / D
        y = Dy / D
        return x, y
    else:
        return False

# ref: Zheng, J., and Hryciw, R.D. (2015).
# “Traditional Soil Particle Sphericity, Roundness and Surface Roughness by
# Computational Geometry”,  Géotechnique, Vol. 65, No. 6, 494-506,
# DOI:10.1680/geot./14-P-192.
def convexpoints(seglist, center):
    """
    Not true deterination of convex points. Determine whether a point is
    convex based on the immediate neighbouring points. If the intersection of a
    ray from the specified center with the line joining the immediate
    neighbouring points is closer to the center than the point itself then the
    point is not convex.

    Input: seglist, an array of points [[x1, y1], [x2, y2], ...]
           center, coordinates of the center point

    Ouput: convex, an array of convex points [[x1, y1], [x2, y2], ...]
           concave, an array of concave points [[x1, y1], [x2, y2], ...]
    """
    # center
    cX, cY = center

    # create an empty list hold the coordinate of convex points
    concave = []
    convex = []

    # save the length of the seglist
    seglen = len(seglist)
    # prepend the second last point before the first
    seglist = np.insert(seglist, 0, seglist[-2], axis=0)
    # append the second point to the end of the array, which is now the third
    # element after prepending the second last element before the first element
    seglist = np.append(seglist, [seglist[2]], axis=0)

    # from the first to the last point check for convex points
    for i in np.arange(0, seglen):
        # calculate distance between the center and the middle element
        cdist = np.sqrt((seglist[i+1][0] - cX)**2 + (seglist[i+1][1] - cY)**2)
        linea = line([seglist[i][0], seglist[i][1]],
                     [seglist[i+2][0], seglist[i+2][1]])
        lineb = line([seglist[i+1][0], seglist[i+1][1]], [cX, cY])

        intx, inty = intersection(linea, lineb)

        intdist = np.sqrt((intx - cX)**2 + (inty - cY)**2)

        # intdist = interdist(seglist[i:i+2], (cX, cY))
        if intdist:
            if intdist >= cdist:
                concave.append(seglist[i+1])
            else:
                convex.append(seglist[i+1])
        else:
            print('WARNING: No single intersection point detected')

    return np.asarray(convex), np.asarray(concave)


# these circle fitting technique has been copied from SciPy Cookbook
# http://scipy-cookbook.readthedocs.io/items/Least_Squares_Circle.html
# the least squares with Jacobian is used because it was stated it was the
# fastest based on the number of calls
def fc(center, x, y):
    """ calculate the algebraic distance between the 2D points and
    the mean circle centered at c=(xc, yc) """
    xc, yc = center
    ri = calc_dist(xc, yc, x, y)
    return ri - np.mean(ri)


def Dfc(center, x, y):
    """ Jacobian of fcircle
    The axis corresponding to derivatives
    must be coherent with the col_deriv option of leastsq"""
    xc, yc = center
    dfc = np.empty((2, x.size))

    radius = calc_dist(xc, yc, x, y)
    # df/dxc and df/dyc
    dfc[0] = (xc - x)/radius
    dfc[1] = (yc - y)/radius
    dfc = dfc - dfc.mean(axis=1)[:, np.newaxis]

    return dfc


def circle_lstsq(center, x, y):
    center_new, ier = leastsq(fc, center, args=(x, y),
                              Dfun=Dfc, col_deriv=True)

    xc_new, yc_new = center_new
    ri = calc_dist(xc_new, yc_new, x, y)
    radius = np.mean(ri)

    return center_new, radius


def corner_circles(convex, cnt, mic, factor, npts):
    """
    Fit circles to the corners

    Input: convex, array of points[[x1, y1], [x2, y2], ...]
           identified as potential convex corner points
           cnt, [[[x1, y1], [x2, y2], ...]] list of points of contour
           mic, radius of the maximum inscribed circle
           factor, tolerance for the fitted radius,
           not worded properly try again
           npts, minimum number of points to consider when fitting the circle

    Output:
    """

    # list of circle centers and radius
    cir_centers = []
    cir_radius = []

    # the indices of first and last points of successful circle fit
    cir_range = []

    # indices of the first and last point
    fp = 0
    lp = len(convex)

    # add the first point after the last point
    convex = np.append(convex, [[convex[0, 0], convex[0, 1]]], axis=0)

    # counter to prevent infinite looping, the maximum iteration for n points
    # will not be more than n * (n-1) in this case even if no circles are
    # found. Need to refine this with proper counting theorem but that is for
    # later
    nmax = lp * (lp - 1)
    n = 0
    while lp >= (fp + npts) and n < nmax:
        # print("fp, lp, fp+npts", fp, lp, fp+npts)
        # consider points from starting point (fp) and ending on the
        # last point to fit the circle
        center_est = (np.mean(convex[fp:lp, 0]), np.mean(convex[fp:lp, 1]))
        center, radius = circle_lstsq(center_est,
                                      convex[fp:lp, 0], convex[fp:lp, 1])
        # center, radius = circle_3b(convex[fp:lp, 0], convex[fp:lp, 1])
        # compute the radial distance from the new center to all the
        # boundary points of the smoothed contour
        min_dist = cv2.pointPolygonTest(cnt, (center[0], center[1]),
                                        measureDist=True)

        # check if the point lies within the particle,
        # revist this to see if it can be done better by removing the
        # nested if statements
        if min_dist < 0:
            # the point does not lie within the particle
            if lp > (fp + npts):
                # drop the last point and start over again
                lp = lp - 1
            else:
                # no circle found for the given point move to next point
                fp += 1
                lp = len(convex)
        elif min_dist >= 0:
            # the point lines within the particle
            if radius < factor * min_dist and radius <= 0.99 * mic:
                # Yeah found a fitting circle
                cir_centers.append([center[0], center[1]])
                cir_radius.append(radius)
                cir_range.append([fp, lp])
                fp = lp + 1
                lp = len(convex)
            elif lp > (fp + npts):
                # if circle not found drop the last point and start over again
                    lp = lp - 1
            else:
                # if circle not found for the given point
                # move to the next point
                fp += 1
                # if no circle found
                lp = len(convex)
                # print('Point inside Here 2')
        n += 1
    return cir_centers, cir_radius, cir_range
